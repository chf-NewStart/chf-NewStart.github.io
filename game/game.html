<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Escape Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: #333;
        }
        
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #764ba2;
            margin-bottom: 20px;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 120px);
            grid-template-rows: repeat(4, 120px);
            gap: 2px;
            background: #333;
            padding: 2px;
            margin: 20px auto;
            width: fit-content;
            position: relative;
        }
        
        .cell {
            background: #f0f0f0;
            border: 1px solid #ccc;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .cell.exit {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
        }
        
        .cell-symbol {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .unit {
            margin: 2px;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .participant {
            background: #4CAF50;
            color: white;
        }
        
        .hunter {
            background: #f44336;
            color: white;
        }

        #toolButtons button.selected { outline:2px solid #764ba2; box-shadow:0 0 0 3px rgba(118,75,162,.25); }
        .cell.blocked { cursor:not-allowed; }
        .cell.placeable { cursor:pointer; }

        
        .door {
            position: absolute;
            background: #666;
            font-size: 10px;
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10;
        }
        
        .door-horizontal {
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            text-align: center;
        }
        
        .door-vertical {
            top: 50%;
            transform: translateY(-50%);
            height: 40px;
            writing-mode: vertical-lr;
            text-align: center;
        }
        
        .door-top {
            top: -15px;
        }
        
        .door-bottom {
            bottom: -15px;
        }
        
        .door-left {
            left: -15px;
        }
        
        .door-right {
            right: -15px;
        }
        .door.frozen {
            outline: 2px solid #00bcd4;
            box-shadow: 0 0 0 2px rgba(0,188,212,.25);
        }

        .door.open {
            background: #4CAF50;
        }
        
        .door.closed {
            background: #FF9800;
        }
        
        .door.locked {
            background: #f44336;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .control-group {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            flex: 1;
            max-width: 300px;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #764ba2;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .dir-btn.selected {
            outline: 2px solid #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,.25);
        }

        
        button:hover:not(:disabled) {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(118, 75, 162, 0.3);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .status {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
        
        .turn-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #764ba2;
            text-align: center;
            margin: 10px 0;
        }
        
        .unit-status {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .unit-card {
            background: white;
            border: 2px solid #ddd;
            padding: 10px;
            border-radius: 8px;
            min-width: 150px;
        }
        
        .unit-card.active {
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .hp-bar {
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .winner {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            animation: pulse 2s infinite;
        }
        
        .winner.participants {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: white;
        }
        
        .winner.hunter {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .log {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            background: white;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üéÆ 4x4 Grid Escape Game üéÆ</h1>
        
        <div class="turn-indicator" id="turnIndicator">Game Not Started</div>
        
        <div class="game-board" id="gameBoard"></div>
        
        <div class="unit-status" id="unitStatus"></div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Game Controls</h3>
                <button onclick="initGame()">New Game</button>
                <button onclick="autoPlay()" id="autoPlayBtn">Auto Play</button>
            </div>
            
        <div class="control-group">
        <h3>Current Unit Actions</h3>
        <div class="control-group" id="setupPanel">
            <h3>Hunter Setup</h3>
            <div id="toolButtons" style="display:flex;flex-wrap:wrap;gap:6px;">
                <button id="tool-XX"  onclick="selectTool('XX')">XX (‰º§ÂÆ≥)</button>
                <button id="tool-‚ñ†"   onclick="selectTool('‚ñ†')">‚ñ† (ÂÜªÁªìÈó®)</button>
                <button id="tool-‚òÜ"   onclick="selectTool('‚òÜ')">‚òÜ (Âç≥Ê≠ª)</button>
                <button id="tool-‚ú¶"   onclick="selectTool('‚ú¶')">‚ú¶ (+1Ë°åÂä®)</button>
                <button id="tool-‚ñ≥"   onclick="selectTool('‚ñ≥')">‚ñ≥ (ÂÖçÊ≠ª‰∏ÄÊ¨°)</button>
                <button id="tool-+"   onclick="selectTool('+')">Ôºã (ÂØπÊñπÂÅú‰∏ÄÂõûÂêà)</button>
            </div>
            <div id="toolHint" style="margin-top:8px;font-size:12px;color:#666;">
                ÁÇπÂáª‰∏Ä‰∏™Â∑•ÂÖ∑ÔºåÁÑ∂ÂêéÂú®Ê£ãÁõò‰∏äÁÇπÂáªË¶ÅÊîæÁΩÆÁöÑÊ†ºÂ≠ê„ÄÇ‰∏çËÉΩÊîæÂú®Ëµ∑ÂßãÊ†º(0,0)‰∏éÂá∫Âè£Ê†º(3,3)„ÄÇ
            </div>
            <div style="margin-top:8px;display:flex;gap:8px;">
                <button onclick="finishSetup()" id="startGameBtn">‚úÖ ÂÆåÊàêÂ∏ÉÁΩÆÔºåÂºÄÂßãÊ∏∏Êàè</button>
                <button onclick="clearSelectedCell()" id="clearCellBtn">üßπ Ê∏ÖÈô§ÊâÄÈÄâÂ∑•ÂÖ∑</button>
            </div>
        </div>


        <!-- Direction selector (first click) -->
        <div style="display:grid;grid-template-columns:repeat(3,60px);gap:6px;justify-content:center;margin-bottom:8px;">
            <div></div>
            <button class="dir-btn" id="dirUp"    onclick="setDir('up')">‚Üë</button>
            <div></div>
            <button class="dir-btn" id="dirLeft"  onclick="setDir('left')">‚Üê</button>
            <div></div>
            <button class="dir-btn" id="dirRight" onclick="setDir('right')">‚Üí</button>
            <div></div>
            <button class="dir-btn" id="dirDown"  onclick="setDir('down')">‚Üì</button>
            <div></div>
        </div>

        <!-- Actions (second click) -->
        <div class="action-buttons" id="actionButtons">
            <button onclick="moveSelected()" id="moveDirBtn">üèÉ Move (dir)</button>

            <button onclick="attackAction()" id="attackBtn">‚öîÔ∏è Attack</button>

            <!-- use selected direction -->
            <button onclick="unlockDoor()" id="unlockBtn">üîì Unlock (dir)</button>
            <button onclick="openDoor()"   id="openBtn">üìÇ Open (dir)</button>
            <button onclick="closeDoor()"  id="closeBtn">üß≤ Close (dir)</button>
            <button onclick="lockDoor()"   id="lockBtn">üîí Lock (dir)</button>

            <button onclick="endTurn()" id="endTurnBtn">‚è≠Ô∏è End Turn</button>
        </div>
        </div>

        </div>
        
        <div class="status">
            <h3>Game Log</h3>
            <div class="log" id="gameLog"></div>
        </div>
        
        <div id="winnerDisplay"></div>
    </div>

    <script>
        class GameEngine {
            constructor() {
                this.grid = Array(4).fill().map(() => Array(4).fill().map(() => ({
                    units: [],
                    symbol: null,
                    isExit: false
                })));
                this.phase = 'setup';                 // 'setup' | 'play' | 'gameover'
                this.selectedTool = null;             // which symbol is selected to place
                // Hunter's toolbox: change counts as you like
                this.toolbox = { 'XX':2, '‚ñ†':2, '‚òÜ':1, '‚ú¶':2, '‚ñ≥':1, '+':1 };

                this.frozenDoors = new Set();     // keys of doors that cannot change
                this.stunHunter = 0;              // >0 means hunter's next turn(s) skipped
                this.stunParticipants = 0;        // >0 means next participant turn(s) skipped

                this.selectedDir = null;
                this.participants = [];
                this.hunter = null;
                this.doors = new Map(); // Key: "x1,y1-x2,y2", Value: state
                this.currentTurn = 0;
                this.currentUnitIndex = 0;
                this.gameOver = false;
                this.winner = null;
                this.actionLog = [];
                this.autoPlayInterval = null;
            }
            
            init() {
                // Reset game state
                this.grid = Array(4).fill().map(() => Array(4).fill().map(() => ({
                    units: [],
                    symbol: null,
                    isExit: false
                })));
                
                // Create participants
                this.participants = [
                    { id: 'P1', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1, hasRevive: false},
                    { id: 'P2', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1, hasRevive: false},
                    { id: 'P3', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1, hasRevive: false},
                    { id: 'P4', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1, hasRevive: false }
                ];
                
                // Create hunter
                this.hunter = { id: 'H', type: 'hunter', hp: 16, maxHp: 16, x: 0, y: 0, actions: 2, maxActions: 2, hasRevive: false};
                
                // Place units on grid
                this.participants.forEach(p => {
                    this.grid[p.y][p.x].units.push(p);
                });
                this.grid[this.hunter.y][this.hunter.x].units.push(this.hunter);
                
                // Set exit
                this.grid[3][3].isExit = true;
                
                
                // Initialize ALL doors between adjacent cells (all start as closed)
                // Horizontal connections (left-right)
                this.doors.set('0,0-1,0', 'locked');
                this.doors.set('1,0-2,0', 'locked');
                this.doors.set('2,0-3,0', 'locked');
                this.doors.set('0,1-1,1', 'locked');
                this.doors.set('1,1-2,1', 'locked');
                this.doors.set('2,1-3,1', 'locked');
                this.doors.set('0,2-1,2', 'locked');
                this.doors.set('1,2-2,2', 'locked');
                this.doors.set('2,2-3,2', 'locked');
                this.doors.set('0,3-1,3', 'locked');
                this.doors.set('1,3-2,3', 'locked');
                this.doors.set('2,3-3,3', 'locked');
                
                // Vertical connections (up-down)
                this.doors.set('0,0-0,1', 'locked');
                this.doors.set('0,1-0,2', 'locked');
                this.doors.set('0,2-0,3', 'locked');
                this.doors.set('1,0-1,1', 'locked');
                this.doors.set('1,1-1,2', 'locked');
                this.doors.set('1,2-1,3', 'locked');
                this.doors.set('2,0-2,1', 'locked');
                this.doors.set('2,1-2,2', 'locked');
                this.doors.set('2,2-2,3', 'locked');
                this.doors.set('3,0-3,1', 'locked');
                this.doors.set('3,1-3,2', 'locked');
                this.doors.set('3,2-3,3', 'locked');
                
                this.currentTurn = 0;
                this.currentUnitIndex = 0;
                this.gameOver = false;
                this.winner = null;
                this.actionLog = [];
                this.phase = 'setup';
                this.selectedTool = null;
                // reset toolbox (optional if you want fresh each game)
                this.toolbox = { 'XX':2, '‚ñ†':2, '‚òÜ':1, '‚ú¶':2, '‚ñ≥':1, '+':1 };

                this.log("Setup phase: Hunter, place your ÈÅìÂÖ∑.");
                this.render();          // just render the empty board now
                this.updateSetupUI();   // show remaining counts, enable tools
            }

            setDirection(dir) {
                this.selectedDir = dir; // remember user‚Äôs selection
                // visual button highlight:
                ['up','down','left','right'].forEach(d => {
                    const btn = document.getElementById('dir' + d.charAt(0).toUpperCase() + d.slice(1));
                    if (btn) btn.classList.toggle('selected', d === dir);
                });
                // Refresh button enables based on chosen door states
                this.updateButtons();
            }
            // UI helper to refresh tool button states and counts
            updateSetupUI() {
            const panel = document.getElementById('setupPanel');
            if (!panel) return;
            // Show panel only during setup
            panel.style.display = (this.phase === 'setup') ? 'block' : 'none';

            // Mark selected tool button and show remaining counts in the labels
            const labels = { 'XX':'XX (‰º§ÂÆ≥)', '‚ñ†':'‚ñ† (ÂÜªÁªìÈó®)', '‚òÜ':'‚òÜ (Âç≥Ê≠ª)', '‚ú¶':'‚ú¶ (+1Ë°åÂä®)', '‚ñ≥':'‚ñ≥ (ÂÖçÊ≠ª‰∏ÄÊ¨°)', '+':'Ôºã (ÂØπÊñπÂÅú‰∏ÄÂõûÂêà)' };
            for (const key of Object.keys(this.toolbox)) {
                const btn = document.getElementById(`tool-${key}`);
                if (!btn) continue;
                btn.textContent = `${labels[key]} √ó${this.toolbox[key]}`;
                btn.disabled = (this.toolbox[key] <= 0);
                btn.classList.toggle('selected', this.selectedTool === key);
            }

            // Start button enabled only when all counts placed or you decide otherwise
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn) {
                const remaining = Object.values(this.toolbox).reduce((a,b)=>a+b,0);
                startBtn.disabled = remaining > 0;
                startBtn.textContent = remaining > 0
                ? `ËøòÂâ© ${remaining} ‰∏™Êú™ÊîæÁΩÆ`
                : '‚úÖ ÂÆåÊàêÂ∏ÉÁΩÆÔºåÂºÄÂßãÊ∏∏Êàè';
            }
            }

            // Called from UI buttons
            setTool(symbol) {
            if (this.phase !== 'setup') return;
            this.selectedTool = symbol;
            this.updateSetupUI();
            }

            // Click on a cell during setup
            placeToolAt(x, y) {
            if (this.phase !== 'setup') return;
            // forbid start cell and exit
            if ((x === 0 && y === 0) || (x === 3 && y === 3)) { this.log('‰∏çËÉΩÊîæÂú®Ëµ∑ÁÇπÊàñÂá∫Âè£'); return; }
            if (!this.selectedTool) { this.log('ÂÖàÈÄâÊã©‰∏Ä‰∏™Â∑•ÂÖ∑'); return; }
            if ((this.toolbox[this.selectedTool] || 0) <= 0) { this.log('ËØ•Â∑•ÂÖ∑Â∑≤Áî®ÂÆå'); return; }

            // place on cell; one cell can hold only one symbol (change if you want stacking)
            const cell = this.grid[y][x];
            if (cell.symbol) { this.log('ËØ•Ê†ºÂ∑≤ÊúâÂ∑•ÂÖ∑ÔºåÂÖàÊ∏ÖÁ©∫'); return; }

            cell.symbol = this.selectedTool;
            this.toolbox[this.selectedTool] -= 1;
            this.log(`ÊîæÁΩÆ ${this.selectedTool} ‰∫é (${x}, ${y})`);
            this.render();
            this.updateSetupUI();
            }

            // Remove any symbol from a cell (for corrections)
            clearToolAt(x, y) {
            if (this.phase !== 'setup') return;
            const cell = this.grid[y][x];
            if (!cell.symbol) return;
            const sym = cell.symbol;
            cell.symbol = null;
            if (this.toolbox[sym] !== undefined) this.toolbox[sym] += 1;
            this.log(`Ê∏ÖÈô§‰∫Ü (${x}, ${y}) ÁöÑ ${sym}`);
            this.render();
            this.updateSetupUI();
            }

            // Start the game
            finishSetup() {
            if (this.phase !== 'setup') return;
            this.phase = 'play';
            this.selectedTool = null;
            this.updateSetupUI();
            this.log('Setup ÂÆåÊàêÔºåÂºÄÂßãÁ¨¨ 1 ÂõûÂêà');
            this.startTurn();
            }


            getAdjacentByDir(unit, dir) {
                let nx = unit.x, ny = unit.y;
                if (dir === 'up') ny--;
                if (dir === 'down') ny++;
                if (dir === 'left') nx--;
                if (dir === 'right') nx++;
                if (nx < 0 || nx > 3 || ny < 0 || ny > 3) return null; // OOB

                const key = this.getDoorKey(unit.x, unit.y, nx, ny);
                const state = this.doors.get(key);
                if (!state) return null; // no door/wall

                return { key, state, nx, ny, dir };
            }


            
            startTurn() {
                if (this.gameOver || this.phase !== 'play') return;
                // If the next unit is stunned, skip their turn
                const u = this.getCurrentUnit();
                if (u) {
                if (u.type === 'hunter' && this.stunHunter > 0) {
                    this.stunHunter -= 1;
                    this.log(`Hunter is stunned and skips this turn (Ôºã)`);
                    // skip entirely
                    this.currentUnitIndex++;
                    return this.startTurn(); // recurse to the next unit safely
                }
                if (u.type === 'participant' && this.stunParticipants > 0) {
                    // find the next alive/active participant to stun
                    this.stunParticipants -= 1;
                    this.log(`Participant turn skipped due to Ôºã`);
                    this.currentUnitIndex++;
                    return this.startTurn();
                }
                }

                this.selectedDir = null;
                ['up','down','left','right'].forEach(d => {
                    const btn = document.getElementById('dir' + d.charAt(0).toUpperCase() + d.slice(1));
                    if (btn) btn.classList.remove('selected');
                });

                let currentUnit = this.getCurrentUnit();
                if (currentUnit) {
                    currentUnit.actions = currentUnit.maxActions;
                    this.log(`${currentUnit.id}'s turn started (${currentUnit.actions} actions)`);
                }
                
                this.render();
            }
            
            getCurrentUnit() {
                if (this.currentUnitIndex < this.participants.length) {
                    return this.participants.find(p => p.hp > 0 && this.participants.indexOf(p) === this.currentUnitIndex);
                } else if (this.currentUnitIndex === this.participants.length) {
                    return this.hunter.hp > 0 ? this.hunter : null;
                }
                return null;
            }
            
            getDoorKey(x1, y1, x2, y2) {
                if (x1 > x2 || (x1 === x2 && y1 > y2)) {
                    return `${x2},${y2}-${x1},${y1}`;
                }
                return `${x1},${y1}-${x2},${y2}`;
            }
            
            getDoorState(x1, y1, x2, y2) {
                const key = this.getDoorKey(x1, y1, x2, y2);
                return this.doors.get(key) || 'open';
            }
            
            move(direction) {
                if (this.phase !== 'play') { this.log('Still in setup phase. Finish setup first.'); return false; }
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;
                
                let newX = unit.x;
                let newY = unit.y;
                
                switch(direction) {
                    case 'up': newY--; break;
                    case 'down': newY++; break;
                    case 'left': newX--; break;
                    case 'right': newX++; break;
                }
                
                // Check bounds
                if (newX < 0 || newX >= 4 || newY < 0 || newY >= 4) {
                    this.log(`${unit.id} cannot move ${direction} - out of bounds`);
                    return false;
                }
                
                // Check door
                const doorState = this.getDoorState(unit.x, unit.y, newX, newY);
                if (doorState !== 'open') {
                    this.log(`${unit.id} cannot move ${direction} - door is ${doorState}`);
                    return false;
                }
                
                // Move unit
                this.grid[unit.y][unit.x].units = this.grid[unit.y][unit.x].units.filter(u => u !== unit);
                unit.x = newX;
                unit.y = newY;
                this.grid[unit.y][unit.x].units.push(unit);
                
                unit.actions--;
                this.log(`${unit.id} moved ${direction} to (${unit.x}, ${unit.y})`);
                
                // Apply cell effects
                this.applyCellEffects(unit);
                
                // Check win conditions
                this.checkWinConditions();
                
                if (unit.actions <= 0) {
                    this.nextTurn();
                } else {
                    this.render();
                }
                if (this.gameOver) { 
                    this.render();
                    return true; 
                }
                
                return true;
            }
            
            applyCellEffects(unit) {
            const cell = this.grid[unit.y][unit.x];
            if (!cell) return;

            // XX: 1 damage on entry
            if (cell.symbol === 'XX') {
                unit.hp = Math.max(0, unit.hp - 1);
                this.log(`${unit.id} took 1 damage from trap! (HP: ${unit.hp})`);
            }

            // ‚òÜ: instant death (respect ‚ñ≥ revive)
            if (cell.symbol === '‚òÜ') {
                if (unit.hasRevive) {
                unit.hasRevive = false;
                unit.hp = Math.max(unit.hp, 1);
                this.log(`${unit.id} cheated death with ‚ñ≥ (revive) and stays at 1 HP!`);
                // consume the tile
                cell.symbol = null;
                } else {
                unit.hp = 0;
                this.log(`${unit.id} died instantly from death trap!`);
                }
            }

            // ‚ñ≥: grant one-time death immunity (consume)
            if (cell.symbol === '‚ñ≥') {
                unit.hasRevive = true;
                this.log(`${unit.id} gained ‚ñ≥ (one-time death immunity)!`);
                cell.symbol = null;
            }

            // ‚ú¶: +1 action (consume)
            if (cell.symbol === '‚ú¶') {
                unit.actions++;
                this.log(`${unit.id} gained ‚ú¶ (+1 action this turn)!`);
                cell.symbol = null;
            }

            // Ôºã: stun the other side for one upcoming turn (consume)
            if (cell.symbol === '+') {
                if (unit.type === 'participant') {
                this.stunHunter += 1;
                this.log(`${unit.id} triggered Ôºã: Hunter will skip their next turn`);
                } else {
                this.stunParticipants += 1;
                this.log(`${unit.id} triggered Ôºã: The next Participant turn will be skipped`);
                }
                cell.symbol = null;
            }

            // ‚ñ†: freeze ALL adjacent doors to this cell (persistent)
            if (cell.symbol === '‚ñ†') {
                const adjs = [
                {nx: unit.x, ny: unit.y - 1, dir: 'up'},
                {nx: unit.x, ny: unit.y + 1, dir: 'down'},
                {nx: unit.x - 1, ny: unit.y, dir: 'left'},
                {nx: unit.x + 1, ny: unit.y, dir: 'right'}
                ];
                let frozenCount = 0;
                for (const a of adjs) {
                if (a.nx < 0 || a.nx > 3 || a.ny < 0 || a.ny > 3) continue;
                const k = this.getDoorKey(unit.x, unit.y, a.nx, a.ny);
                if (this.doors.has(k)) {
                    this.frozenDoors.add(k);
                    frozenCount++;
                }
                }
                this.log(`${unit.id} activated ‚ñ†: froze ${frozenCount} adjacent door(s)`);
                // (leave the tile there to indicate area is "frozen source", or remove if you prefer)
                // cell.symbol = null;
            }

            // Exit check
            if (cell.isExit && unit.type === 'participant') {
                this.log(`${unit.id} escaped through the exit!`);
                unit.escaped = true;
            }
            }

            
            attack() {
                if (this.phase !== 'play') { this.log('Still in setup phase. Finish setup first.'); return false; }
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                const cell = this.grid[unit.y][unit.x];
                let target = null;

                if (unit.type === 'participant') {
                    target = cell.units.find(u => u.type === 'hunter');
                    if (target) {
                        target.hp = Math.max(0, target.hp - 2);
                        this.log(`${unit.id} attacked ${target.id} for 2 damage! (HP: ${target.hp})`);
                        // after damage assignment but before logging death/win
                        if (target.hp <= 0 && target.hasRevive) {
                            target.hasRevive = false;
                            target.hp = 1;
                            this.log(`${target.id} avoided death with ‚ñ≥ and stays at 1 HP!`);
                        }

                    }
                } else if (unit.type === 'hunter') {
                    // üîí Block attacks in the first round
                    if (this.currentTurn === 0) {
                        this.log(`${unit.id} cannot attack in the first round!`);
                        return false;
                    }

                    const targets = cell.units.filter(u => u.type === 'participant' && u.hp > 0);
                    if (targets.length > 0) {
                        target = targets[0];
                        target.hp = Math.max(0, target.hp - 3);
                        // after damage assignment but before logging death/win
                        if (target.hp <= 0 && target.hasRevive) {
                            target.hasRevive = false;
                            target.hp = 1;
                            this.log(`${target.id} avoided death with ‚ñ≥ and stays at 1 HP!`);
                        }

                        this.log(`${unit.id} attacked ${target.id} for 2 damage! (HP: ${target.hp})`);
                    }
                }

                if (!target) {
                    this.log(`${unit.id} has no valid targets to attack`);
                    return false;
                }

                unit.actions--;

                this.checkWinConditions();

                if (unit.actions <= 0) {
                    this.nextTurn();
                } else {
                    this.render();
                }

                if (this.gameOver) { 
                    this.render();
                    return true; 
                }

                return true;
            }

            
            unlockDoor(dir = this.selectedDir) {
                if (this.phase !== 'play') { this.log('Still in setup phase. Finish setup first.'); return false; }
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                // If direction chosen, use it; else fallback to first adjacent locked (old behavior)
                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'locked') {
                    // fallback scan
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'locked') { target = cand; break; }
                    }
                }
                if (target && this.frozenDoors.has(target.key)) {
                    this.log(`Door ${target.dir} is frozen and cannot be changed`);
                    return false;
                }
                if (!target || target.state !== 'locked') {
                    this.log(`${unit.id} has no locked door to unlock`);
                    return false;
                }
                this.doors.set(target.key, 'closed');

                unit.actions--;
                this.log(`${unit.id} unlocked ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            openDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'closed') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'closed') { target = cand; break; }
                    }
                }

                if (target && this.frozenDoors.has(target.key)) {
                    this.log(`Door ${target.dir} is frozen and cannot be changed`);
                    return false;
                }
                if (!target || target.state !== 'closed') {
                    this.log(`${unit.id} has no closed door to open`);
                    return false;
                }
                this.doors.set(target.key, 'open');
                unit.actions--;
                this.log(`${unit.id} opened ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            // NEW: Close an OPEN door
            closeDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'open') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'open') { target = cand; break; }
                    }
                }
                if (target && this.frozenDoors.has(target.key)) {
                    this.log(`Door ${target.dir} is frozen and cannot be changed`);
                    return false;
                }
                if (!target || target.state !== 'open') {
                    this.log(`${unit.id} has no open door to close`);
                    return false;
                }
                this.doors.set(target.key, 'closed');
                unit.actions--;
                this.log(`${unit.id} closed ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            // NEW: Lock a CLOSED door
            lockDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'closed') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'closed') { target = cand; break; }
                    }
                }
                if (target && this.frozenDoors.has(target.key)) {
                    this.log(`Door ${target.dir} is frozen and cannot be changed`);
                    return false;
                }
                if (!target || target.state !== 'closed') {
                    this.log(`${unit.id} has no closed door to lock`);
                    return false;
                }
                this.doors.set(target.key, 'locked');
                unit.actions--;
                this.log(`${unit.id} locked ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }
            moveDir(dir = this.selectedDir) {
                if (this.phase !== 'play') { this.log('Still in setup phase. Finish setup first.'); return false; }
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                // If a direction is selected, try that; else do nothing (explicit control)
                if (!dir) {
                    this.log(`${unit.id} no direction selected for Move`);
                    return false;
                }
                return this.move(dir); // uses your existing move() which checks door/open/etc
            }

            
            nextTurn() {
                if (this.gameOver) return;
                
                // Move to next unit
                this.currentUnitIndex++;
                
                // Skip dead participants
                while (this.currentUnitIndex < this.participants.length) {
                    if (this.participants[this.currentUnitIndex].hp > 0 && 
                        !this.participants[this.currentUnitIndex].escaped) {
                        break;
                    }
                    this.currentUnitIndex++;
                }
                
                // Check if round is complete
                if (this.currentUnitIndex > this.participants.length) {
                    this.currentUnitIndex = 0;
                    this.currentTurn++;
                    this.log(`--- Round ${this.currentTurn + 1} ---`);
                    
                    // Skip dead participants at start of new round
                    while (this.currentUnitIndex < this.participants.length) {
                        if (this.participants[this.currentUnitIndex].hp > 0 && 
                            !this.participants[this.currentUnitIndex].escaped) {
                            break;
                        }
                        this.currentUnitIndex++;
                    }
                }
                
                this.startTurn();
            }
            
            checkWinConditions() {
            // participant escaped
            if (this.participants.some(p => p.escaped)) {
                this.gameOver = true;
                this.winner = 'participants';
                this.log("üéâ Participants WIN! A participant escaped!");

                // üîß stop autoplay & render immediately
                if (this.autoPlayInterval) {
                clearInterval(this.autoPlayInterval);
                this.autoPlayInterval = null;
                const btn = document.getElementById('autoPlayBtn');
                if (btn) btn.textContent = 'Auto Play';
                }
                this.render();
                return;
            }

            // hunter dead
            if (this.hunter.hp <= 0) {
                this.gameOver = true;
                this.winner = 'participants';
                this.log("üéâ Participants WIN! Hunter defeated!");

                if (this.autoPlayInterval) {
                clearInterval(this.autoPlayInterval);
                this.autoPlayInterval = null;
                const btn = document.getElementById('autoPlayBtn');
                if (btn) btn.textContent = 'Auto Play';
                }
                this.render();
                return;
            }

            // all participants dead
            if (this.participants.every(p => p.hp <= 0)) {
                this.gameOver = true;
                this.winner = 'hunter';
                this.log("üíÄ Hunter WINS! All participants eliminated!");

                if (this.autoPlayInterval) {
                clearInterval(this.autoPlayInterval);
                this.autoPlayInterval = null;
                const btn = document.getElementById('autoPlayBtn');
                if (btn) btn.textContent = 'Auto Play';
                }
                this.render();
                return;
            }
            }

            
            log(message) {
                this.actionLog.push(message);
                const logDiv = document.getElementById('gameLog');
                if (logDiv) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.textContent = message;
                    logDiv.appendChild(entry);
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
            }
            
            render() {
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                
                // Render cells
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (this.grid[y][x].isExit) {
                            cell.classList.add('exit');
                            cell.innerHTML += '<div style="position:absolute;top:5px;left:5px;font-weight:bold;">EXIT</div>';
                        }

                        // Click to place/remove
                        if (this.phase === 'setup') {
                        if ((x === 0 && y === 0) || (x === 3 && y === 3)) {
                            cell.classList.add('blocked');
                        } else {
                            cell.classList.add('placeable');
                            cell.onclick = () => {
                            // If there is already a symbol, clicking removes it. Otherwise place selected tool.
                            if (this.grid[y][x].symbol) {
                                this.clearToolAt(x, y);
                            } else {
                                this.placeToolAt(x, y);
                            }
                            };
                        }
                        }
                        
                        // Add symbol
                        if (this.grid[y][x].symbol) {
                            cell.innerHTML += `<div class="cell-symbol">${this.grid[y][x].symbol}</div>`;
                        }
                        
                        // Add units
                        this.grid[y][x].units.forEach(unit => {
                            if (unit.hp > 0 && !unit.escaped) {
                                const unitDiv = document.createElement('div');
                                unitDiv.className = `unit ${unit.type}`;
                                unitDiv.textContent = `${unit.id} (${unit.hp}HP)`;
                                cell.appendChild(unitDiv);
                            }
                        });
                        
                        // Add doors
                        // --- Top door ---
                        if (y > 0) {
                        const keyTop = this.getDoorKey(x, y, x, y - 1);
                        if (this.doors.has(keyTop)) {
                            const doorStateTop = this.getDoorState(x, y, x, y - 1);   // <‚Äî define it
                            const door = document.createElement('div');
                            door.className = `door door-horizontal door-top ${doorStateTop}`;
                            if (this.frozenDoors.has(keyTop)) door.classList.add('frozen');

                            let doorText = '';
                            if (doorStateTop === 'locked') doorText = 'üîíLOCKED';
                            else if (doorStateTop === 'closed') doorText = 'üö™CLOSED';
                            else doorText = '‚úÖOPEN';
                            if (this.frozenDoors.has(keyTop)) doorText += ' ‚ùÑÔ∏è';
                            door.textContent = doorText;
                            cell.appendChild(door);
                        }
                        }

                        // --- Left door ---
                        if (x > 0) {
                        const keyLeft = this.getDoorKey(x, y, x - 1, y);
                        if (this.doors.has(keyLeft)) {
                            const doorStateLeft = this.getDoorState(x, y, x - 1, y);   // <‚Äî define it
                            const door = document.createElement('div');
                            door.className = `door door-vertical door-left ${doorStateLeft}`;
                            if (this.frozenDoors.has(keyLeft)) door.classList.add('frozen');

                            let doorText = '';
                            if (doorStateLeft === 'locked') doorText = 'üîíLOCKED';
                            else if (doorStateLeft === 'closed') doorText = 'üö™CLOSED';
                            else doorText = '‚úÖOPEN';
                            if (this.frozenDoors.has(keyLeft)) doorText += ' ‚ùÑÔ∏è';
                            door.textContent = doorText;
                            cell.appendChild(door);
                        }
                        }

                        
                        board.appendChild(cell);
                    }
                }
                
                // Update status display
                this.updateStatusDisplay();
            }
            
            updateStatusDisplay() {
                const statusDiv = document.getElementById('unitStatus');
                statusDiv.innerHTML = '';
                
                // Participants status
                this.participants.forEach((p, index) => {
                    const card = document.createElement('div');
                    card.className = 'unit-card';
                    if (this.currentUnitIndex === index && !this.gameOver) {
                        card.classList.add('active');
                    }
                    
                    const hpPercent = (p.hp / p.maxHp) * 100;
                    card.innerHTML = `
                        <strong>${p.id}</strong>
                        ${p.escaped ? '<span style="color:green"> (ESCAPED)</span>' : ''}
                        ${p.hp <= 0 ? '<span style="color:red"> (DEAD)</span>' : ''}
                        <div class="hp-bar">
                            <div class="hp-fill" style="width:${hpPercent}%"></div>
                        </div>
                        <small>HP: ${p.hp}/${p.maxHp} | Actions: ${p.actions}</small>
                    `;
                    statusDiv.appendChild(card);
                });
                
                // Hunter status
                const hunterCard = document.createElement('div');
                hunterCard.className = 'unit-card';
                if (this.currentUnitIndex === this.participants.length && !this.gameOver) {
                    hunterCard.classList.add('active');
                }
                
                const hpPercent = (this.hunter.hp / this.hunter.maxHp) * 100;
                hunterCard.innerHTML = `
                    <strong>${this.hunter.id} (Hunter)</strong>
                    ${this.hunter.hp <= 0 ? '<span style="color:red"> (DEAD)</span>' : ''}
                    <div class="hp-bar">
                        <div class="hp-fill" style="width:${hpPercent}%; background: linear-gradient(90deg, #f44336, #ff6b6b);"></div>
                    </div>
                    <small>HP: ${this.hunter.hp}/${this.hunter.maxHp} | Actions: ${this.hunter.actions}</small>
                `;
                statusDiv.appendChild(hunterCard);
                
                // Update turn indicator
                const turnDiv = document.getElementById('turnIndicator');
                if (this.gameOver) {
                    turnDiv.textContent = 'Game Over!';
                } else {
                    const currentUnit = this.getCurrentUnit();
                    if (currentUnit) {
                        turnDiv.textContent = `Current Turn: ${currentUnit.id} (${currentUnit.type}) - Round ${this.currentTurn + 1}`;
                    }
                }
                
                // Update winner display
                const winnerDiv = document.getElementById('winnerDisplay');
                if (this.gameOver) {
                    winnerDiv.className = `winner ${this.winner}`;
                    winnerDiv.textContent = this.winner === 'participants' ? 
                        'üéâ PARTICIPANTS WIN! üéâ' : 'üíÄ HUNTER WINS! üíÄ';
                } else {
                    winnerDiv.innerHTML = '';
                    winnerDiv.className = '';
                }
                
                // Update button states
                this.updateButtons();
            }
            
            updateButtons() {
                const unit = this.getCurrentUnit();
                const hasActions = unit && unit.actions > 0;
                const isGameOver = this.gameOver;
                
                // document.getElementById('moveUpBtn').disabled = !hasActions || isGameOver;
                // document.getElementById('moveDownBtn').disabled = !hasActions || isGameOver;
                // document.getElementById('moveLeftBtn').disabled = !hasActions || isGameOver;
                // document.getElementById('moveRightBtn').disabled = !hasActions || isGameOver;
                document.getElementById('attackBtn').disabled = !hasActions || isGameOver;
                if (unit && unit.type === 'hunter' && this.currentTurn === 0) {
                    document.getElementById('attackBtn').disabled = true;
                }

                document.getElementById('unlockBtn').disabled = !hasActions || isGameOver;
                document.getElementById('openBtn').disabled = !hasActions || isGameOver;
                document.getElementById('endTurnBtn').disabled = !unit || isGameOver;
                const moveDirBtn = document.getElementById('moveDirBtn');
                if (moveDirBtn) {
                    if (!unit || isGameOver) {
                        moveDirBtn.disabled = true;
                    } else if (this.selectedDir) {
                        const adj = this.getAdjacentByDir(unit, this.selectedDir);
                        // enable Move only if the selected edge exists and is open
                        moveDirBtn.disabled = !hasActions || !adj || adj.state !== 'open';
                    } else {
                        // no direction selected ‚Üí disabled
                        moveDirBtn.disabled = true;
                    }
                }


                // Optional: if a direction is selected, enable/disable action buttons based on that door state
                if (unit && !isGameOver && this.selectedDir) {
                    const adj = this.getAdjacentByDir(unit, this.selectedDir);
                    const unlockBtn = document.getElementById('unlockBtn');
                    const openBtn   = document.getElementById('openBtn');
                    const closeBtn  = document.getElementById('closeBtn');
                    const lockBtn   = document.getElementById('lockBtn');

                    if (adj) {
                        if (unlockBtn) unlockBtn.disabled = !hasActions || adj.state !== 'locked';
                        if (openBtn)   openBtn.disabled   = !hasActions || adj.state !== 'closed';
                        if (closeBtn)  closeBtn.disabled  = !hasActions || adj.state !== 'open';
                        if (lockBtn)   lockBtn.disabled   = !hasActions || adj.state !== 'closed';
                    } else {
                        // no door / out of bounds
                        if (unlockBtn) unlockBtn.disabled = true;
                        if (openBtn)   openBtn.disabled   = true;
                        if (closeBtn)  closeBtn.disabled  = true;
                        if (lockBtn)   lockBtn.disabled   = true;
                    }
                }

            }
        }
        
        // Game instance
        let game = null;
        
        // Initialize game
        function initGame() {
            console.log('Initializing new game...');
            const gameBoard = document.getElementById('gameBoard');
            const gameLog = document.getElementById('gameLog');
            
            if (!gameBoard) {
                console.error('Game board element not found!');
                return;
            }
            
            if (gameLog) {
                gameLog.innerHTML = '';
            }
            
            if (game && game.autoPlayInterval) {
                clearInterval(game.autoPlayInterval);
            }
            
            game = new GameEngine();
            game.init();
            document.getElementById('autoPlayBtn').textContent = 'Auto Play';
            console.log('Game initialized successfully');
        }
        
        // Movement functions
        function moveUnit(direction) {
            if (game) game.move(direction);
        }
        
        // Action functions
        function attackAction() {
            if (game) game.attack();
        }
        
        function unlockDoor() {
            if (game) game.unlockDoor();
        }
        
        function openDoor() {
            if (game && game.phase !== 'play') { game.log('Still in setup phase. Finish setup first.'); return; }
            if (game) game.openDoor();
        }
        
        function endTurn() {
            if (game) {
                const unit = game.getCurrentUnit();
                if (unit) {
                    unit.actions = 0;
                    game.nextTurn();
                }
            }
        }

        function moveSelected() {
            if (game) game.moveDir();
        }

        
        // Auto-play functionality
        function autoPlay() {
            if (!game) return;
            if (game.phase !== 'play') {
                game.finishSetup(); // auto-start if still in setup
            }
            
            if (game.autoPlayInterval) {
                clearInterval(game.autoPlayInterval);
                game.autoPlayInterval = null;
                document.getElementById('autoPlayBtn').textContent = 'Auto Play';
                return;
            }
            
            document.getElementById('autoPlayBtn').textContent = 'Stop Auto';
            
            game.autoPlayInterval = setInterval(() => {
                if (game.gameOver) {
                    clearInterval(game.autoPlayInterval);
                    game.autoPlayInterval = null;
                    document.getElementById('autoPlayBtn').textContent = 'Auto Play';
                    return;
                }
                
                const unit = game.getCurrentUnit();
                if (!unit) return;
                
                // Simple AI logic
                if (unit.type === 'participant') {
                    // Participants try to reach exit at bottom-right
                    const exitX = 3, exitY = 3;
                    const dx = exitX - unit.x;
                    const dy = exitY - unit.y;
                    
                    // Try to move toward exit
                    let moved = false;
                    
                    // Prioritize moving toward exit
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0) moved = game.move('right');
                        else if (dx < 0) moved = game.move('left');
                        
                        if (!moved) {
                            if (dy > 0) moved = game.move('down');
                            else if (dy < 0) moved = game.move('up');
                        }
                    } else {
                        if (dy > 0) moved = game.move('down');
                        else if (dy < 0) moved = game.move('up');
                        
                        if (!moved) {
                            if (dx > 0) moved = game.move('right');
                            else if (dx < 0) moved = game.move('left');
                        }
                    }
                    
                    // If can't move, try to unlock or open doors
                    if (!moved) {
                        if (!game.unlockDoor()) {
                            if (!game.openDoor()) {
                                // Attack if hunter is in same cell
                                if (!game.attack()) {
                                    // End turn if nothing else to do
                                    unit.actions = 0;
                                    game.nextTurn();
                                }
                            }
                        }
                    }
                } else if (unit.type === 'hunter') {
                    // Gather live participants
                    const aliveParticipants = game.participants.filter(p => p.hp > 0 && !p.escaped);

                    // If nobody left, end hunter's turn
                    if (aliveParticipants.length === 0) {
                        unit.actions = 0;
                        game.nextTurn();
                        return;
                    }

                    // Find nearest participant
                    let target = aliveParticipants[0];
                    let minDist = Math.abs(target.x - unit.x) + Math.abs(target.y - unit.y);
                    for (const p of aliveParticipants) {
                        const d = Math.abs(p.x - unit.x) + Math.abs(p.y - unit.y);
                        if (d < minDist) { minDist = d; target = p; }
                    }

                    // If on the same cell and not first round ‚Üí attack
                    if (minDist === 0) {
                        if (game.currentTurn > 0) { game.attack(); }
                        else { // first round: cannot attack; try to reposition
                            unit.actions = 0;
                            game.nextTurn();
                        }
                        return;
                    }

                    // Choose preferred direction(s) toward target
                    const dx = target.x - unit.x;
                    const dy = target.y - unit.y;
                    const primaryDir  = Math.abs(dx) >= Math.abs(dy)
                        ? (dx > 0 ? 'right' : 'left')
                        : (dy > 0 ? 'down'  : 'up');
                    const secondaryDir = Math.abs(dx) >= Math.abs(dy)
                        ? (dy > 0 ? 'down'  : 'up')
                        : (dx > 0 ? 'right' : 'left');

                    // Try primary, then secondary
                    const tryDirs = [primaryDir, secondaryDir];

                    let acted = false;
                    for (const dir of tryDirs) {
                        // Inspect the door between unit and that neighbor
                        const adj = game.getAdjacentByDir(unit, dir); // { key, state, nx, ny, dir } or null
                        if (!adj) continue; // wall / out of bounds

                        if (adj.state === 'open') {
                            // Move through
                            acted = game.move(dir);
                        } else if (adj.state === 'closed') {
                            // Open it
                            acted = game.openDoor(dir);
                        } else if (adj.state === 'locked') {
                            // Unlock it
                            acted = game.unlockDoor(dir);
                        }
                        if (acted) break; // consumed one action; let timer tick again
                    }

                    if (!acted) {
                        // If both directions were walls or failed, try the other two as a fallback
                        const fallback = ['up','down','left','right'].filter(d => !tryDirs.includes(d));
                        for (const dir of fallback) {
                            const adj = game.getAdjacentByDir(unit, dir);
                            if (!adj) continue;
                            if (adj.state === 'open' && game.move(dir)) { acted = true; break; }
                            if (adj.state === 'closed' && game.openDoor(dir)) { acted = true; break; }
                            if (adj.state === 'locked' && game.unlockDoor(dir)) { acted = true; break; }
                        }
                    }

                    // If still nothing useful to do, end hunter's turn to avoid stalling
                    if (!acted) {
                        unit.actions = 0;
                        game.nextTurn();
                    }
                }
            }, 1000); // Move every second
        }
        function setDir(dir) {
            if (game) game.setDirection(dir);
        }
        function closeDoor() {
            if (game && game.phase !== 'play') { game.log('Still in setup phase. Finish setup first.'); return; }
            if (game) game.closeDoor(); // uses selected dir if set
        }
        function lockDoor() {
            if (game && game.phase !== 'play') { game.log('Still in setup phase. Finish setup first.'); return; }
            if (game) game.lockDoor();  // uses selected dir if set
        }
        function selectTool(sym){ if (game) game.setTool(sym); }
        function finishSetup(){ if (game) game.finishSetup(); }
        function clearSelectedCell(){
            // clears the cell you last clicked; or, click directly on the board (see next section)
            alert('ÊèêÁ§∫ÔºöÁõ¥Êé•Âú®Ê£ãÁõò‰∏äÂÜçÊ¨°ÁÇπÂáªÂ∑≤ÊúâÁ¨¶Âè∑ÁöÑÊ†ºÂ≠êÂç≥ÂèØÊ∏ÖÈô§„ÄÇ');
        }

        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing game...');
            initGame();
        });
    </script>
</body>
</html>