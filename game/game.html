<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Grid Escape Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: #333;
        }
        
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #764ba2;
            margin-bottom: 20px;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(4, 120px);
            grid-template-rows: repeat(4, 120px);
            gap: 2px;
            background: #333;
            padding: 2px;
            margin: 20px auto;
            width: fit-content;
            position: relative;
        }
        
        .cell {
            background: #f0f0f0;
            border: 1px solid #ccc;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .cell.exit {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
        }
        
        .cell-symbol {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .unit {
            margin: 2px;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .participant {
            background: #4CAF50;
            color: white;
        }
        
        .hunter {
            background: #f44336;
            color: white;
        }
        
        .door {
            position: absolute;
            background: #666;
            font-size: 10px;
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10;
        }
        
        .door-horizontal {
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            text-align: center;
        }
        
        .door-vertical {
            top: 50%;
            transform: translateY(-50%);
            height: 40px;
            writing-mode: vertical-lr;
            text-align: center;
        }
        
        .door-top {
            top: -15px;
        }
        
        .door-bottom {
            bottom: -15px;
        }
        
        .door-left {
            left: -15px;
        }
        
        .door-right {
            right: -15px;
        }
        
        .door.open {
            background: #4CAF50;
        }
        
        .door.closed {
            background: #FF9800;
        }
        
        .door.locked {
            background: #f44336;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .control-group {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            flex: 1;
            max-width: 300px;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #764ba2;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .dir-btn.selected {
            outline: 2px solid #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,.25);
        }

        
        button:hover:not(:disabled) {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(118, 75, 162, 0.3);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .status {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
        
        .turn-indicator {
            font-size: 18px;
            font-weight: bold;
            color: #764ba2;
            text-align: center;
            margin: 10px 0;
        }
        
        .unit-status {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .unit-card {
            background: white;
            border: 2px solid #ddd;
            padding: 10px;
            border-radius: 8px;
            min-width: 150px;
        }
        
        .unit-card.active {
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .hp-bar {
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .winner {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            animation: pulse 2s infinite;
        }
        
        .winner.participants {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: white;
        }
        
        .winner.hunter {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .log {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            background: white;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üéÆ 4x4 Grid Escape Game üéÆ</h1>
        
        <div class="turn-indicator" id="turnIndicator">Game Not Started</div>
        
        <div class="game-board" id="gameBoard"></div>
        
        <div class="unit-status" id="unitStatus"></div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Game Controls</h3>
                <button onclick="initGame()">New Game</button>
                <button onclick="autoPlay()" id="autoPlayBtn">Auto Play</button>
            </div>
            
        <div class="control-group">
        <h3>Current Unit Actions</h3>

        <!-- Direction selector (first click) -->
        <div style="display:grid;grid-template-columns:repeat(3,60px);gap:6px;justify-content:center;margin-bottom:8px;">
            <div></div>
            <button class="dir-btn" id="dirUp"    onclick="setDir('up')">‚Üë</button>
            <div></div>
            <button class="dir-btn" id="dirLeft"  onclick="setDir('left')">‚Üê</button>
            <div></div>
            <button class="dir-btn" id="dirRight" onclick="setDir('right')">‚Üí</button>
            <div></div>
            <button class="dir-btn" id="dirDown"  onclick="setDir('down')">‚Üì</button>
            <div></div>
        </div>

        <!-- Actions (second click) -->
        <div class="action-buttons" id="actionButtons">
            <button onclick="moveUnit('up')" id="moveUpBtn">‚Üë Move Up</button>
            <button onclick="moveUnit('down')" id="moveDownBtn">‚Üì Move Down</button>
            <button onclick="moveUnit('left')" id="moveLeftBtn">‚Üê Move Left</button>
            <button onclick="moveUnit('right')" id="moveRightBtn">‚Üí Move Right</button>

            <button onclick="attackAction()" id="attackBtn">‚öîÔ∏è Attack</button>

            <!-- use selected direction -->
            <button onclick="unlockDoor()" id="unlockBtn">üîì Unlock (dir)</button>
            <button onclick="openDoor()"   id="openBtn">üìÇ Open (dir)</button>
            <button onclick="closeDoor()"  id="closeBtn">üß≤ Close (dir)</button>
            <button onclick="lockDoor()"   id="lockBtn">üîí Lock (dir)</button>

            <button onclick="endTurn()" id="endTurnBtn">‚è≠Ô∏è End Turn</button>
        </div>
        </div>

        </div>
        
        <div class="status">
            <h3>Game Log</h3>
            <div class="log" id="gameLog"></div>
        </div>
        
        <div id="winnerDisplay"></div>
    </div>

    <script>
        class GameEngine {
            constructor() {
                this.grid = Array(4).fill().map(() => Array(4).fill().map(() => ({
                    units: [],
                    symbol: null,
                    isExit: false
                })));
                this.selectedDir = null;
                this.participants = [];
                this.hunter = null;
                this.doors = new Map(); // Key: "x1,y1-x2,y2", Value: state
                this.currentTurn = 0;
                this.currentUnitIndex = 0;
                this.gameOver = false;
                this.winner = null;
                this.actionLog = [];
                this.autoPlayInterval = null;
            }
            
            init() {
                // Reset game state
                this.grid = Array(4).fill().map(() => Array(4).fill().map(() => ({
                    units: [],
                    symbol: null,
                    isExit: false
                })));
                
                // Create participants
                this.participants = [
                    { id: 'P1', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1 },
                    { id: 'P2', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1 },
                    { id: 'P3', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1 },
                    { id: 'P4', type: 'participant', hp: 5, maxHp: 5, x: 0, y: 0, actions: 1, maxActions: 1 }
                ];
                
                // Create hunter
                this.hunter = { id: 'H', type: 'hunter', hp: 16, maxHp: 16, x: 0, y: 0, actions: 3, maxActions: 3 };
                
                // Place units on grid
                this.participants.forEach(p => {
                    this.grid[p.y][p.x].units.push(p);
                });
                this.grid[this.hunter.y][this.hunter.x].units.push(this.hunter);
                
                // Set exit
                this.grid[3][3].isExit = true;
                
                // Set symbols (examples)
                this.grid[2][2].symbol = 'XX'; // Damage
                this.grid[1][3].symbol = '‚ú¶'; // Extra action
                this.grid[2][0].symbol = '‚òÜ'; // Instant death
                
                // Initialize ALL doors between adjacent cells (all start as closed)
                // Horizontal connections (left-right)
                this.doors.set('0,0-1,0', 'locked');
                this.doors.set('1,0-2,0', 'locked');
                this.doors.set('2,0-3,0', 'locked');
                this.doors.set('0,1-1,1', 'locked');
                this.doors.set('1,1-2,1', 'locked');
                this.doors.set('2,1-3,1', 'locked');
                this.doors.set('0,2-1,2', 'locked');
                this.doors.set('1,2-2,2', 'locked');
                this.doors.set('2,2-3,2', 'locked');
                this.doors.set('0,3-1,3', 'locked');
                this.doors.set('1,3-2,3', 'locked');
                this.doors.set('2,3-3,3', 'locked');
                
                // Vertical connections (up-down)
                this.doors.set('0,0-0,1', 'locked');
                this.doors.set('0,1-0,2', 'locked');
                this.doors.set('0,2-0,3', 'locked');
                this.doors.set('1,0-1,1', 'locked');
                this.doors.set('1,1-1,2', 'locked');
                this.doors.set('1,2-1,3', 'locked');
                this.doors.set('2,0-2,1', 'locked');
                this.doors.set('2,1-2,2', 'locked');
                this.doors.set('2,2-2,3', 'locked');
                this.doors.set('3,0-3,1', 'locked');
                this.doors.set('3,1-3,2', 'locked');
                this.doors.set('3,2-3,3', 'locked');
                
                this.currentTurn = 0;
                this.currentUnitIndex = 0;
                this.gameOver = false;
                this.winner = null;
                this.actionLog = [];
                
                this.log("Game initialized!");
                this.startTurn();
            }
            setDirection(dir) {
                this.selectedDir = dir; // remember user‚Äôs selection
                // visual button highlight:
                ['up','down','left','right'].forEach(d => {
                    const btn = document.getElementById('dir' + d.charAt(0).toUpperCase() + d.slice(1));
                    if (btn) btn.classList.toggle('selected', d === dir);
                });
                // Refresh button enables based on chosen door states
                this.updateButtons();
            }

            getAdjacentByDir(unit, dir) {
                let nx = unit.x, ny = unit.y;
                if (dir === 'up') ny--;
                if (dir === 'down') ny++;
                if (dir === 'left') nx--;
                if (dir === 'right') nx++;
                if (nx < 0 || nx > 3 || ny < 0 || ny > 3) return null; // OOB

                const key = this.getDoorKey(unit.x, unit.y, nx, ny);
                const state = this.doors.get(key);
                if (!state) return null; // no door/wall

                return { key, state, nx, ny, dir };
            }


            
            startTurn() {
                if (this.gameOver) return;
                
                let currentUnit = this.getCurrentUnit();
                if (currentUnit) {
                    currentUnit.actions = currentUnit.maxActions;
                    this.log(`${currentUnit.id}'s turn started (${currentUnit.actions} actions)`);
                }
                
                this.render();
            }
            
            getCurrentUnit() {
                if (this.currentUnitIndex < this.participants.length) {
                    return this.participants.find(p => p.hp > 0 && this.participants.indexOf(p) === this.currentUnitIndex);
                } else if (this.currentUnitIndex === this.participants.length) {
                    return this.hunter.hp > 0 ? this.hunter : null;
                }
                return null;
            }
            
            getDoorKey(x1, y1, x2, y2) {
                if (x1 > x2 || (x1 === x2 && y1 > y2)) {
                    return `${x2},${y2}-${x1},${y1}`;
                }
                return `${x1},${y1}-${x2},${y2}`;
            }
            
            getDoorState(x1, y1, x2, y2) {
                const key = this.getDoorKey(x1, y1, x2, y2);
                return this.doors.get(key) || 'open';
            }
            
            move(direction) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;
                
                let newX = unit.x;
                let newY = unit.y;
                
                switch(direction) {
                    case 'up': newY--; break;
                    case 'down': newY++; break;
                    case 'left': newX--; break;
                    case 'right': newX++; break;
                }
                
                // Check bounds
                if (newX < 0 || newX >= 4 || newY < 0 || newY >= 4) {
                    this.log(`${unit.id} cannot move ${direction} - out of bounds`);
                    return false;
                }
                
                // Check door
                const doorState = this.getDoorState(unit.x, unit.y, newX, newY);
                if (doorState !== 'open') {
                    this.log(`${unit.id} cannot move ${direction} - door is ${doorState}`);
                    return false;
                }
                
                // Move unit
                this.grid[unit.y][unit.x].units = this.grid[unit.y][unit.x].units.filter(u => u !== unit);
                unit.x = newX;
                unit.y = newY;
                this.grid[unit.y][unit.x].units.push(unit);
                
                unit.actions--;
                this.log(`${unit.id} moved ${direction} to (${unit.x}, ${unit.y})`);
                
                // Apply cell effects
                this.applyCellEffects(unit);
                
                // Check win conditions
                this.checkWinConditions();
                
                if (unit.actions <= 0) {
                    this.nextTurn();
                } else {
                    this.render();
                }
                
                return true;
            }
            
            applyCellEffects(unit) {
                const cell = this.grid[unit.y][unit.x];
                
                if (cell.symbol === 'XX') {
                    unit.hp = Math.max(0, unit.hp - 1);
                    this.log(`${unit.id} took 1 damage from trap! (HP: ${unit.hp})`);
                }
                
                if (cell.symbol === '‚òÜ') {
                    unit.hp = 0;
                    this.log(`${unit.id} died instantly from death trap!`);
                }
                
                if (cell.symbol === '‚ú¶') {
                    unit.actions++;
                    this.log(`${unit.id} gained +1 action!`);
                    cell.symbol = null; // Consume the bonus
                }
                
                if (cell.isExit && unit.type === 'participant') {
                    this.log(`${unit.id} escaped through the exit!`);
                    unit.escaped = true;
                }
            }
            
            attack() {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;
                
                const cell = this.grid[unit.y][unit.x];
                let target = null;
                
                if (unit.type === 'participant') {
                    target = cell.units.find(u => u.type === 'hunter');
                    if (target) {
                        target.hp = Math.max(0, target.hp - 2);
                        this.log(`${unit.id} attacked ${target.id} for 2 damage! (HP: ${target.hp})`);
                    }
                else if (unit.type === 'hunter' && this.currentTurn === 0) {
                        this.log(`${unit.id} cannot attack in the first round!`);
                        return false;
                }
                } else if (unit.type === 'hunter') {
                    const targets = cell.units.filter(u => u.type === 'participant' && u.hp > 0);
                    if (targets.length > 0) {
                        target = targets[0];
                        target.hp = Math.max(0, target.hp - 3);
                        this.log(`${unit.id} attacked ${target.id} for 3 damage! (HP: ${target.hp})`);
                    }
                }
                
                if (!target) {
                    this.log(`${unit.id} has no valid targets to attack`);
                    return false;
                }
                
                unit.actions--;
                
                this.checkWinConditions();
                
                if (unit.actions <= 0) {
                    this.nextTurn();
                } else {
                    this.render();
                }
                
                return true;
            }
            
            unlockDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                // If direction chosen, use it; else fallback to first adjacent locked (old behavior)
                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'locked') {
                    // fallback scan
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'locked') { target = cand; break; }
                    }
                }
                if (!target || target.state !== 'locked') {
                    this.log(`${unit.id} has no locked door to unlock`);
                    return false;
                }
                this.doors.set(target.key, 'closed');
                unit.actions--;
                this.log(`${unit.id} unlocked ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            openDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'closed') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'closed') { target = cand; break; }
                    }
                }
                if (!target || target.state !== 'closed') {
                    this.log(`${unit.id} has no closed door to open`);
                    return false;
                }
                this.doors.set(target.key, 'open');
                unit.actions--;
                this.log(`${unit.id} opened ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            // NEW: Close an OPEN door
            closeDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'open') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'open') { target = cand; break; }
                    }
                }
                if (!target || target.state !== 'open') {
                    this.log(`${unit.id} has no open door to close`);
                    return false;
                }
                this.doors.set(target.key, 'closed');
                unit.actions--;
                this.log(`${unit.id} closed ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            // NEW: Lock a CLOSED door
            lockDoor(dir = this.selectedDir) {
                const unit = this.getCurrentUnit();
                if (!unit || unit.actions <= 0) return false;

                let target = dir ? this.getAdjacentByDir(unit, dir) : null;
                if (!target || target.state !== 'closed') {
                    const dirs = ['up','down','left','right'];
                    for (const d of dirs) {
                        const cand = this.getAdjacentByDir(unit, d);
                        if (cand && cand.state === 'closed') { target = cand; break; }
                    }
                }
                if (!target || target.state !== 'closed') {
                    this.log(`${unit.id} has no closed door to lock`);
                    return false;
                }
                this.doors.set(target.key, 'locked');
                unit.actions--;
                this.log(`${unit.id} locked ${target.dir} door`);
                unit.actions <= 0 ? this.nextTurn() : this.render();
                return true;
            }

            
            nextTurn() {
                if (this.gameOver) return;
                
                // Move to next unit
                this.currentUnitIndex++;
                
                // Skip dead participants
                while (this.currentUnitIndex < this.participants.length) {
                    if (this.participants[this.currentUnitIndex].hp > 0 && 
                        !this.participants[this.currentUnitIndex].escaped) {
                        break;
                    }
                    this.currentUnitIndex++;
                }
                
                // Check if round is complete
                if (this.currentUnitIndex > this.participants.length) {
                    this.currentUnitIndex = 0;
                    this.currentTurn++;
                    this.log(`--- Round ${this.currentTurn + 1} ---`);
                    
                    // Skip dead participants at start of new round
                    while (this.currentUnitIndex < this.participants.length) {
                        if (this.participants[this.currentUnitIndex].hp > 0 && 
                            !this.participants[this.currentUnitIndex].escaped) {
                            break;
                        }
                        this.currentUnitIndex++;
                    }
                }
                
                this.startTurn();
            }
            
            checkWinConditions() {
                // Check if any participant escaped
                if (this.participants.some(p => p.escaped)) {
                    this.gameOver = true;
                    this.winner = 'participants';
                    this.log("üéâ Participants WIN! A participant escaped!");
                    return;
                }
                
                // Check if hunter is dead
                if (this.hunter.hp <= 0) {
                    this.gameOver = true;
                    this.winner = 'participants';
                    this.log("üéâ Participants WIN! Hunter defeated!");
                    return;
                }
                
                // Check if all participants are dead
                if (this.participants.every(p => p.hp <= 0)) {
                    this.gameOver = true;
                    this.winner = 'hunter';
                    this.log("üíÄ Hunter WINS! All participants eliminated!");
                    return;
                }
            }
            
            log(message) {
                this.actionLog.push(message);
                const logDiv = document.getElementById('gameLog');
                if (logDiv) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.textContent = message;
                    logDiv.appendChild(entry);
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
            }
            
            render() {
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                
                // Render cells
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (this.grid[y][x].isExit) {
                            cell.classList.add('exit');
                            cell.innerHTML += '<div style="position:absolute;top:5px;left:5px;font-weight:bold;">EXIT</div>';
                        }
                        
                        // Add symbol
                        if (this.grid[y][x].symbol) {
                            cell.innerHTML += `<div class="cell-symbol">${this.grid[y][x].symbol}</div>`;
                        }
                        
                        // Add units
                        this.grid[y][x].units.forEach(unit => {
                            if (unit.hp > 0 && !unit.escaped) {
                                const unitDiv = document.createElement('div');
                                unitDiv.className = `unit ${unit.type}`;
                                unitDiv.textContent = `${unit.id} (${unit.hp}HP)`;
                                cell.appendChild(unitDiv);
                            }
                        });
                        
                        // Add doors
                        // Top door
                        if (y > 0) {
                            const doorState = this.getDoorState(x, y, x, y - 1);
                            if (this.doors.has(this.getDoorKey(x, y, x, y - 1))) {
                                const door = document.createElement('div');
                                door.className = `door door-horizontal door-top ${doorState}`;
                                let doorText = '';
                                if (doorState === 'locked') {
                                    doorText = 'üîíLOCKED';
                                } else if (doorState === 'closed') {
                                    doorText = 'üö™CLOSED';
                                } else {
                                    doorText = '‚úÖOPEN';
                                }
                                door.textContent = doorText;
                                cell.appendChild(door);
                            }
                        }
                        
                        // Left door
                        if (x > 0) {
                            const doorState = this.getDoorState(x, y, x - 1, y);
                            if (this.doors.has(this.getDoorKey(x, y, x - 1, y))) {
                                const door = document.createElement('div');
                                door.className = `door door-vertical door-left ${doorState}`;
                                let doorText = '';
                                if (doorState === 'locked') {
                                    doorText = 'üîíLOCKED';
                                } else if (doorState === 'closed') {
                                    doorText = 'üö™CLOSED';
                                } else {
                                    doorText = '‚úÖOPEN';
                                }
                                door.textContent = doorText;
                                cell.appendChild(door);
                            }
                        }
                        
                        board.appendChild(cell);
                    }
                }
                
                // Update status display
                this.updateStatusDisplay();
            }
            
            updateStatusDisplay() {
                const statusDiv = document.getElementById('unitStatus');
                statusDiv.innerHTML = '';
                
                // Participants status
                this.participants.forEach((p, index) => {
                    const card = document.createElement('div');
                    card.className = 'unit-card';
                    if (this.currentUnitIndex === index && !this.gameOver) {
                        card.classList.add('active');
                    }
                    
                    const hpPercent = (p.hp / p.maxHp) * 100;
                    card.innerHTML = `
                        <strong>${p.id}</strong>
                        ${p.escaped ? '<span style="color:green"> (ESCAPED)</span>' : ''}
                        ${p.hp <= 0 ? '<span style="color:red"> (DEAD)</span>' : ''}
                        <div class="hp-bar">
                            <div class="hp-fill" style="width:${hpPercent}%"></div>
                        </div>
                        <small>HP: ${p.hp}/${p.maxHp} | Actions: ${p.actions}</small>
                    `;
                    statusDiv.appendChild(card);
                });
                
                // Hunter status
                const hunterCard = document.createElement('div');
                hunterCard.className = 'unit-card';
                if (this.currentUnitIndex === this.participants.length && !this.gameOver) {
                    hunterCard.classList.add('active');
                }
                
                const hpPercent = (this.hunter.hp / this.hunter.maxHp) * 100;
                hunterCard.innerHTML = `
                    <strong>${this.hunter.id} (Hunter)</strong>
                    ${this.hunter.hp <= 0 ? '<span style="color:red"> (DEAD)</span>' : ''}
                    <div class="hp-bar">
                        <div class="hp-fill" style="width:${hpPercent}%; background: linear-gradient(90deg, #f44336, #ff6b6b);"></div>
                    </div>
                    <small>HP: ${this.hunter.hp}/${this.hunter.maxHp} | Actions: ${this.hunter.actions}</small>
                `;
                statusDiv.appendChild(hunterCard);
                
                // Update turn indicator
                const turnDiv = document.getElementById('turnIndicator');
                if (this.gameOver) {
                    turnDiv.textContent = 'Game Over!';
                } else {
                    const currentUnit = this.getCurrentUnit();
                    if (currentUnit) {
                        turnDiv.textContent = `Current Turn: ${currentUnit.id} (${currentUnit.type}) - Round ${this.currentTurn + 1}`;
                    }
                }
                
                // Update winner display
                const winnerDiv = document.getElementById('winnerDisplay');
                if (this.gameOver) {
                    winnerDiv.className = `winner ${this.winner}`;
                    winnerDiv.textContent = this.winner === 'participants' ? 
                        'üéâ PARTICIPANTS WIN! üéâ' : 'üíÄ HUNTER WINS! üíÄ';
                } else {
                    winnerDiv.innerHTML = '';
                    winnerDiv.className = '';
                }
                
                // Update button states
                this.updateButtons();
            }
            
            updateButtons() {
                const unit = this.getCurrentUnit();
                const hasActions = unit && unit.actions > 0;
                const isGameOver = this.gameOver;
                
                document.getElementById('moveUpBtn').disabled = !hasActions || isGameOver;
                document.getElementById('moveDownBtn').disabled = !hasActions || isGameOver;
                document.getElementById('moveLeftBtn').disabled = !hasActions || isGameOver;
                document.getElementById('moveRightBtn').disabled = !hasActions || isGameOver;
                document.getElementById('attackBtn').disabled = !hasActions || isGameOver;
                document.getElementById('unlockBtn').disabled = !hasActions || isGameOver;
                document.getElementById('openBtn').disabled = !hasActions || isGameOver;
                document.getElementById('endTurnBtn').disabled = !unit || isGameOver;

                // Optional: if a direction is selected, enable/disable action buttons based on that door state
                if (unit && !isGameOver && this.selectedDir) {
                    const adj = this.getAdjacentByDir(unit, this.selectedDir);
                    const unlockBtn = document.getElementById('unlockBtn');
                    const openBtn   = document.getElementById('openBtn');
                    const closeBtn  = document.getElementById('closeBtn');
                    const lockBtn   = document.getElementById('lockBtn');

                    if (adj) {
                        if (unlockBtn) unlockBtn.disabled = !hasActions || adj.state !== 'locked';
                        if (openBtn)   openBtn.disabled   = !hasActions || adj.state !== 'closed';
                        if (closeBtn)  closeBtn.disabled  = !hasActions || adj.state !== 'open';
                        if (lockBtn)   lockBtn.disabled   = !hasActions || adj.state !== 'closed';
                    } else {
                        // no door / out of bounds
                        if (unlockBtn) unlockBtn.disabled = true;
                        if (openBtn)   openBtn.disabled   = true;
                        if (closeBtn)  closeBtn.disabled  = true;
                        if (lockBtn)   lockBtn.disabled   = true;
                    }
                }

            }
        }
        
        // Game instance
        let game = null;
        
        // Initialize game
        function initGame() {
            console.log('Initializing new game...');
            const gameBoard = document.getElementById('gameBoard');
            const gameLog = document.getElementById('gameLog');
            
            if (!gameBoard) {
                console.error('Game board element not found!');
                return;
            }
            
            if (gameLog) {
                gameLog.innerHTML = '';
            }
            
            if (game && game.autoPlayInterval) {
                clearInterval(game.autoPlayInterval);
            }
            
            game = new GameEngine();
            game.init();
            document.getElementById('autoPlayBtn').textContent = 'Auto Play';
            console.log('Game initialized successfully');
        }
        
        // Movement functions
        function moveUnit(direction) {
            if (game) game.move(direction);
        }
        
        // Action functions
        function attackAction() {
            if (game) game.attack();
        }
        
        function unlockDoor() {
            if (game) game.unlockDoor();
        }
        
        function openDoor() {
            if (game) game.openDoor();
        }
        
        function endTurn() {
            if (game) {
                const unit = game.getCurrentUnit();
                if (unit) {
                    unit.actions = 0;
                    game.nextTurn();
                }
            }
        }
        
        // Auto-play functionality
        function autoPlay() {
            if (!game) return;
            
            if (game.autoPlayInterval) {
                clearInterval(game.autoPlayInterval);
                game.autoPlayInterval = null;
                document.getElementById('autoPlayBtn').textContent = 'Auto Play';
                return;
            }
            
            document.getElementById('autoPlayBtn').textContent = 'Stop Auto';
            
            game.autoPlayInterval = setInterval(() => {
                if (game.gameOver) {
                    clearInterval(game.autoPlayInterval);
                    game.autoPlayInterval = null;
                    document.getElementById('autoPlayBtn').textContent = 'Auto Play';
                    return;
                }
                
                const unit = game.getCurrentUnit();
                if (!unit) return;
                
                // Simple AI logic
                if (unit.type === 'participant') {
                    // Participants try to reach exit at bottom-right
                    const exitX = 3, exitY = 3;
                    const dx = exitX - unit.x;
                    const dy = exitY - unit.y;
                    
                    // Try to move toward exit
                    let moved = false;
                    
                    // Prioritize moving toward exit
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 0) moved = game.move('right');
                        else if (dx < 0) moved = game.move('left');
                        
                        if (!moved) {
                            if (dy > 0) moved = game.move('down');
                            else if (dy < 0) moved = game.move('up');
                        }
                    } else {
                        if (dy > 0) moved = game.move('down');
                        else if (dy < 0) moved = game.move('up');
                        
                        if (!moved) {
                            if (dx > 0) moved = game.move('right');
                            else if (dx < 0) moved = game.move('left');
                        }
                    }
                    
                    // If can't move, try to unlock or open doors
                    if (!moved) {
                        if (!game.unlockDoor()) {
                            if (!game.openDoor()) {
                                // Attack if hunter is in same cell
                                if (!game.attack()) {
                                    // End turn if nothing else to do
                                    unit.actions = 0;
                                    game.nextTurn();
                                }
                            }
                        }
                    }
                } else if (unit.type === 'hunter') {
                    // Gather live participants
                    const aliveParticipants = game.participants.filter(p => p.hp > 0 && !p.escaped);

                    // If nobody left, end hunter's turn
                    if (aliveParticipants.length === 0) {
                        unit.actions = 0;
                        game.nextTurn();
                        return;
                    }

                    // Find nearest participant
                    let target = aliveParticipants[0];
                    let minDist = Math.abs(target.x - unit.x) + Math.abs(target.y - unit.y);
                    for (const p of aliveParticipants) {
                        const d = Math.abs(p.x - unit.x) + Math.abs(p.y - unit.y);
                        if (d < minDist) { minDist = d; target = p; }
                    }

                    // If on the same cell and not first round ‚Üí attack
                    if (minDist === 0) {
                        if (game.currentTurn > 0) { game.attack(); }
                        else { // first round: cannot attack; try to reposition
                            unit.actions = 0;
                            game.nextTurn();
                        }
                        return;
                    }

                    // Choose preferred direction(s) toward target
                    const dx = target.x - unit.x;
                    const dy = target.y - unit.y;
                    const primaryDir  = Math.abs(dx) >= Math.abs(dy)
                        ? (dx > 0 ? 'right' : 'left')
                        : (dy > 0 ? 'down'  : 'up');
                    const secondaryDir = Math.abs(dx) >= Math.abs(dy)
                        ? (dy > 0 ? 'down'  : 'up')
                        : (dx > 0 ? 'right' : 'left');

                    // Try primary, then secondary
                    const tryDirs = [primaryDir, secondaryDir];

                    let acted = false;
                    for (const dir of tryDirs) {
                        // Inspect the door between unit and that neighbor
                        const adj = game.getAdjacentByDir(unit, dir); // { key, state, nx, ny, dir } or null
                        if (!adj) continue; // wall / out of bounds

                        if (adj.state === 'open') {
                            // Move through
                            acted = game.move(dir);
                        } else if (adj.state === 'closed') {
                            // Open it
                            acted = game.openDoor(dir);
                        } else if (adj.state === 'locked') {
                            // Unlock it
                            acted = game.unlockDoor(dir);
                        }
                        if (acted) break; // consumed one action; let timer tick again
                    }

                    if (!acted) {
                        // If both directions were walls or failed, try the other two as a fallback
                        const fallback = ['up','down','left','right'].filter(d => !tryDirs.includes(d));
                        for (const dir of fallback) {
                            const adj = game.getAdjacentByDir(unit, dir);
                            if (!adj) continue;
                            if (adj.state === 'open' && game.move(dir)) { acted = true; break; }
                            if (adj.state === 'closed' && game.openDoor(dir)) { acted = true; break; }
                            if (adj.state === 'locked' && game.unlockDoor(dir)) { acted = true; break; }
                        }
                    }

                    // If still nothing useful to do, end hunter's turn to avoid stalling
                    if (!acted) {
                        unit.actions = 0;
                        game.nextTurn();
                    }
                }
            }, 1000); // Move every second
        }
        function setDir(dir) {
            if (game) game.setDirection(dir);
        }
        function closeDoor() {
            if (game) game.closeDoor(); // uses selected dir if set
        }
        function lockDoor() {
            if (game) game.lockDoor();  // uses selected dir if set
        }

        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing game...');
            initGame();
        });
    </script>
</body>
</html>